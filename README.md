# Decision Tree: Intelligent Systems
## üéØ Objectives
In this project, I explored the use of decision trees on a dataset about the Titanic, with the aim of identifying passengers who survived the sinking. I used characteristics such as age, gender and ticket type to make predictions. The main goal was to demonstrate how this supervised machine learning algorithm can solve binary classification problems, distinguishing between those that survived and those that did not.

## üõ†Ô∏è Technologies
- Python
- Google Colab
- Pandas
- Matplotlib
- Seaborn
- Scikit-learn

## üìä Use of my project
This project can be used to:

‚Ä¢ Learn about decision trees and their application to classification problems.
‚Ä¢ Explore and visualize Titanic data, understanding how different variables influence tree decisions.
‚Ä¢ Evaluate model performance with metrics such as accuracy, precision, recall and F1-score.
‚Ä¢ Compare the results obtained by the decision tree with other algorithms, such as Random Forest, to identify improvements.

## üöÄ Additional Project Details

- Connecting Google Colab to Google Drive: I implemented the connection to facilitate access and manipulation of data stored in Google Drive.
- Importing Required Libraries: I used libraries like Pandas, Matplotlib, Seaborn and Scikit-learn for analysis and model building.
- Exploratory Analysis and Data Cleaning: I performed a detailed analysis of the dataset, treating missing data and outliers.
- Feature Selection: I selected relevant variables to train the model, removing those that did not contribute significantly.
- Model Training: Implemented the decision tree and tuned its hyperparameters to optimize performance.
- Decision Tree Visualization: I used graphs to visualize the structure of the tree generated by the model.
- Using Random Forest: I compared the performance of the decision tree with the Random Forest algorithm.

## üôå Contribution
If you want to contribute to this project, feel free to fork, create a branch, make changes, and submit a pull request. I welcome contributions related to algorithm improvements, data visualizations, additional experimentation or any suggestions that could improve the project.
